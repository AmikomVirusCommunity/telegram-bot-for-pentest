#!/usr/bin/env python
#
# Small stuff bot for pentest
# A library that provides Pentest with Telegram bot
# Nanda Reynaldi <nandareynaldi97@gmail.com>

from telegram import ReplyKeyboardMarkup
from telegram.ext import (Updater, CommandHandler, MessageHandler, Filters, RegexHandler,
                          ConversationHandler)
from multiprocessing import Pool
from multiprocessing import Process
from subprocess import Popen, PIPE
from socket import * 
import hashlib, binascii
import re
import telepot
import json
import urllib
import time
import logging
import os
import time
import base64
import subprocess
import validators
import threading, time

if os.name == 'nt':
	os.system('cls')
else:
	os.system('clear')

# Enable logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                    level=logging.INFO)

logger = logging.getLogger(__name__)

CHOOSING, TYPING_REPLY, TYPING_CHOICE, CHOOSINGPW = range(4)

# Choosing Menu
reply_keyboard = [['Find Sub Domain', 'TCP Port Scan'],
                  ['URL Fuzzer', 'Password Generator', 'Scan HTTP Header'],
                  ['Done']]
markup = ReplyKeyboardMarkup(reply_keyboard, one_time_keyboard=True)


def facts_to_str(user_data):
    facts = list()

    for key, value in user_data.items():
        facts.append('{} - {}'.format(key, value))

    return "\n".join(facts).join(['\n', '\n'])

# This is Welcome message when user hit /start
def start_bot(bot, update):
    update.message.reply_text(
        "Hi! I'm AV3C Bot. I can do whatever the fuck you want. Go Fucking Do It! \r\n \r\n if bot doesn't respond. maybe you are in queue",
        reply_markup=markup)

    return CHOOSING


def regular_choice(bot, update, user_data):
    text = update.message.text
    user_data['choice'] = text
    name = update.message.from_user

    # Create User log who use this bot into log.txt. So you can monitoring bot usage
    with open('log.txt','rU+') as f:
        f.seek(-2,2)
        if(f.read(2) == "\n\n"): # add new line for new log activity
            f.seek(-1,2)
        f.write("-: %s" % name + " " + text + "\n")
    
    #Execute from Menu
    if text == 'Find Sub Domain': # Message if user select Find Sub Domain
        update.message.reply_text(
            'You want me to {}? Yes, I am burnt the fuck out, But I still can do about it! please tell me the domain.\r\n'
            '---------------------\r\n'
            '<option> <target>\r\n'
            'Example:\r\n'
            '-d avc.or.id -p 80,443\r\n'
            '---------------------------\r\n'
            '---------OPTIONS---------->\r\n'
            '---------------------------\r\n'
            '-d | Domain name to enumerate.\r\n'
            '-b | Enable the bruteforce module.\r\n'
            '-p | Scan & get specific ports.\r\n'
            '-v | Verbose mode.\r\n'
            '-t | Number of threads Bruteforce.\r\n'
            '-e | Specify of search engines.\r\n'
            '-h | Show the help message.\r\n'.format(text.lower()))
            
    elif text == 'Password Generator': # Message if user select Password Generator
        update.message.reply_text(
            'This feature allows you to generate random passwords. Please Choose some algorithm.\r\n'
            '---------------------\r\n'
            'Support Algorithm\r\n'
            '---------------------\r\n'
            '-md5 <string>\r\n'
            '-sha256 <string>\r\n'
            '-sha512 <string>\r\n'
            '-base64 <string>\r\n'
            '-encode-base64 <string>\r\n'
            '-decode-base64 <string_to_decode>\r\n'
            'Example: -md5 1234\r\n'.format(text.lower()))
    
    elif text == 'TCP Port Scan': # Message if user select TCP Port Scan
        update.message.reply_text(
            'The TCP Port Scanner uses Nmap to find open ports in your target systems. This process takes a long time. Tell me the target.'.format(text.lower()))

    elif text == 'URL Fuzzer':
         update.message.reply_text(
            'This feature allows you to find fucking vuln directory. Please tell me the target.\r\n'
            '---------------------\r\n'
            'Options\r\n'
            '---------------------\r\n'
            '-d <target> | Search for directory\r\n'
            '-f <target> | Search for files\r\n'
            'Example: -d avc.or.id\r\n'.format(text.lower()))

    elif text == 'Scan HTTP Header': # Message if user select HTTP Header Scan
         update.message.reply_text(
            'This feature allows you to scan HTTP response headers.Please tell me the target.\r\n'
            '---------------------\r\n'
            'Options\r\n'
            '---------------------\r\n'
            '-u | The URL to be scanned.\r\n'
            '-U | Set the User-Agent request header\r\n'
            '-i | Disable certificate verification.\r\n'
            'Example: -i -u avc.or.id\r\n'.format(text.lower()))    

    else: # Else
        update.message.reply_text("I can't do that. Use our command bellow".format(
                                  facts_to_str(user_data)), reply_markup=markup)
    return TYPING_REPLY


def received_information(bot, update, user_data):
    text = update.message.text
    category = user_data['choice']
    gen = text #get command messages from user
    user_data[category] = gen
    del user_data['choice']

    if category == "Find Sub Domain": # Find Sub Domain program
        update.message.reply_text("One Moment Please.")
        update.message.reply_text("One Moment Please..")
        update.message.reply_text("One Moment Please...")
        update.message.reply_text("\xE2\x9C\x94 Retrieving data")
        execute = subprocess.Popen('python tools/sublister/run.py ' + gen, stdin = PIPE, stdout=subprocess.PIPE, shell=True)
        text = execute.communicate()[0]
        update.message.reply_text(text.format(
                                    facts_to_str(user_data)), reply_markup=markup)

    elif category == "Password Generator": # Password Generator program
        split = gen.split(" ")
        get_algo = split[0]

        if get_algo == "-md5":
            generate = hashlib.md5(split[1]).hexdigest()
        elif get_algo == "-sha256":
            generate = hashlib.sha256(split[1]).hexdigest()
        elif get_algo == "-sha512":
            generate = hashlib.sha512(split[1]).hexdigest()
        elif get_algo == "-encode-base64":
            generate = base64.b64encode(split[1])
        elif get_algo == "-decode-base64":
            generate = base64.b64decode(split[1])
        else:
           return ConversationHandler.END

        update.message.reply_text(generate.format(
                                  facts_to_str(user_data)), reply_markup=markup)

    elif category == "TCP Port Scan": # TCP Port Scan program
        update.message.reply_text("This process takes a long time.")
        update.message.reply_text("One moment please.")
        update.message.reply_text("One moment please..")
        update.message.reply_text("One moment please...")
        update.message.reply_text("\xE2\x9C\x94 Retrieving data")
        domain = text

        # Domain check validation. Dont run program if domain format is invalid
        domain_check = re.compile("^(http|https)?[a-zA-Z0-9]+([\-\.]{1}[a-zA-Z0-9]+)*\.[a-zA-Z]{2,}$")
        if not domain_check.match(domain):
            if domain_check.match(domain):
                print("Error: Please enter a valid domain")
        else:
            targetserver = text
            for i in range(1, 1025):
                s = socket(AF_INET, SOCK_STREAM)

                result = s.connect_ex((targetserver, i))

                if(result == 0) :
                    update.message.reply_text("Port %d: OPEN" % (i,))

        update.message.reply_text("--Done--".format(
                                  facts_to_str(user_data)), reply_markup=markup)

    elif category == "URL Fuzzer": # URL Fuzzer program
        update.message.reply_text("Server Error: (['api.avc.or.id:2029'])".format(
                                    facts_to_str(user_data)), reply_markup=markup)

    elif category == "Scan HTTP Header":
        #url = urllib.urlopen("http://" + gen)
        #response_headers = url.info()
        #server      = str(response_headers['server'])
        #date        = response_headers['date']
        #content     = response_headers['content-type']
        #cache       = response_headers['cache-control']
        #connection  = response_headers['connection']
        #via         = response_headers['via']
        #expires     = response_headers['expires']
        #country     = response_headers['x-country-code']
        #age         = response_headers['age']
        
       # get_all = server + '\r\n' + date + '\r\n' + content  + '\r\n' + connection + '\r\n' + expires + '\r\n' + country + '\r\n' + age

        #print get_all
        #print response_headers
        #print response_headers.keys()
        update.message.reply_text("Server Error: (['api.avc.or.id:2029'])".format(
                                    facts_to_str(user_data)), reply_markup=markup)
    else:
        update.message.reply_text("Server Error: (['api.avc.or.id:2029'])".format(
                                    facts_to_str(user_data)), reply_markup=markup)
    
    #You can add more stuff in this line by add new ELIF condition and execute that program

    return CHOOSING


def done(bot, update, user_data): # Message to closing a bot
    if 'choice' in user_data:
        del user_data['choice']
    update.message.reply_text("Thank you very much.\r\n"
                              "Latest activity: {} \r\n" #show latest user activity
                              "We will add other stuff as soon as posible.".format(facts_to_str(user_data)))

    user_data.clear()
    return ConversationHandler.END


def error(bot, update, error):
    """Log Errors caused by Updates."""
    logger.warning('Update "%s" caused error "%s"', update, error)
    


def main():
    # Create the Updater and pass it your bot's token.
    updater = Updater("PASTE-HERE-YOUR-API-TOKEN") # Paste your token bot here
    print '[+] Server is Listenining [+]' # Your bot is running

    # Get the dispatcher to register handlers
    dp = updater.dispatcher

    # Add conversation handler with the pentest modules
    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start_bot)], #Start bot

        states={
            CHOOSING: [RegexHandler('^(Find Sub Domain|TCP Port Scan|URL Fuzzer|Password Generator|Password Generator|Scan HTTP Header)$',
                                    regular_choice,
                                    pass_user_data=True),
                            ],
    
            TYPING_CHOICE: [MessageHandler(Filters.text,
                                           regular_choice,
                                           pass_user_data=True),
                            ],

            TYPING_REPLY: [MessageHandler(Filters.text,
                                          received_information,
                                          pass_user_data=True),
                           ],
        },

        fallbacks=[RegexHandler('^Done$', done, pass_user_data=True)]
    )

    dp.add_handler(conv_handler)

    # log all errors
    dp.add_error_handler(error)

    # Start the Bot
    updater.start_polling()

    # Run the bot until you press Ctrl-C or the process receives SIGINT,
    updater.idle()

def f(x):
    return x*x

if __name__ == '__main__':
    #Create non block program
    p = Process(target=main)
    p.start()
    p.join()